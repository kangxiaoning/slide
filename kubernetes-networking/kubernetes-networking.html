<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Kubernetes Networking</title>
<meta name="author" content="kangxiaoning"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="/Users/kangxiaoning/workspace/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="/Users/kangxiaoning/workspace/reveal.js/dist/theme/white.css" id="theme"/>
<link rel="stylesheet" href="/Users/kangxiaoning/workspace/reveal.js/plugin/highlight/zenburn.css"/>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Kubernetes Networking</h1><h2 class="author">kangxiaoning</h2><p class="date">Created: 2022-05-26 Thu 18:31</p>
</section>


<section>
<section id="slide-org08bce8a">
<h2 id="org08bce8a">Objectives</h2>
<ul>
<li class="fragment appear">Understand networking and Linux primitives that power Kubernetes</li>
<li class="fragment appear">Understand the Container Network Interface (CNI) project</li>
<li class="fragment appear">Understand the Kubernetes networking model</li>

</ul>


</section>
</section>
<section>
<section id="slide-org2ff525b">
<h2 id="org2ff525b">Agenda</h2>
<ul>
<li>TCP/IP and OSI</li>
<li>Linux Networking</li>
<li>Kubernetes networking model</li>

</ul>


</section>
</section>
<section>
<section id="slide-orgb1b4268">
<h2 id="orgb1b4268">TCP/IP and OSI</h2>
<ul>
<li>IP</li>
<li>TCP</li>
<li>TLS</li>
<li>VXLAN</li>

</ul>

</section>
<section id="slide-orge112fd0" data-background="./images/tcpip-and-osi.png" data-background-size="500px">
<h3 id="orge112fd0"></h3>

</section>
<section id="slide-org7d7ee55">
<h3 id="org7d7ee55">IP Header</h3>
<div class="outline-text-3" id="text-org7d7ee55">
</div>
</section>
<section id="slide-orgf5a08a3" data-background="./images/ipv4-header.svg" data-background-size="1000px">
<h4 id="orgf5a08a3"></h4>

</section>
<section id="slide-org70a0d45">
<h4 id="org70a0d45">IP Header fields</h4>
<div style="font-size: 90%;">
<ul>
<li><b>Internet Header Length (IHL)</b>
<ul>
<li>The IPv4 header has a variable size due to the optional 14th field option.</li>

</ul></li>
<li><b>Identification</b>
<ul>
<li>This is the identification field and is used for uniquely identifying the group of fragments of a single IP datagram.</li>

</ul></li>
<li><b>Flags</b>
<ul>
<li>This is used to control or identify fragments. In order from most significant to least:</li>
<li>bit 0: Reserved, set to zero</li>
<li>bit 1: Do not Fragment</li>
<li>bit 2: More Fragments</li>

</ul></li>
<li><b>Time To Live (TTL)</b>
<ul>
<li>An 8-bit time to live field helps prevent datagrams from going in circles on a network.</li>

</ul></li>

</ul>
</div>

</section>
<section id="slide-org501a7fd">
<h4 id="org501a7fd">IP Header in wireshark</h4>
</section>
<section id="slide-orgf51cc85" data-background="./images/ipv4-header-wireshark.png" data-background-size="1400px">
<h4 id="orgf51cc85"></h4>

</section>
<section id="slide-orgee1c77b">
<h3 id="orgee1c77b">TCP Header</h3>
<div class="outline-text-3" id="text-orgee1c77b">
</div>
</section>
<section id="slide-org0d226f2" data-background="./images/tcp-header.svg" data-background-size="1000px">
<h4 id="org0d226f2"></h4>

</section>
<section id="slide-org6d39d60">
<h4 id="org6d39d60">TCP Header fields</h4>
<div style="font-size: 90%;">
<ul>
<li><b>Sequence number (32 bits)</b>
<ul>
<li>If the SYN flag is set, this is the initial sequence number. The sequence number of the first data byte and the acknowledged number in the corresponding ACK is this sequence number plus 1. It is also used to reassemble data if it arrives out of order.</li>

</ul></li>
<li><b>Acknowledgment number (32 bits)</b>
<ul>
<li>If the ACK flag is set, then this field’s value is the next sequence number of the ACK the sender is expecting. This acknowledges receipt of all preceding bytes (if any). Each end’s first ACK acknowledges the other end’s initial sequence number itself, but no data has been sent.</li>

</ul></li>
<li><b>Window size (16 bits)</b>
<ul>
<li>This is the size of the receive window.</li>

</ul></li>
<li><b>Options</b>
<ul>
<li>Variable 0–320 bits, in units of 32 bits.</li>

</ul></li>
<li><b>Padding</b>
<ul>
<li>The TCP header padding is used to ensure that the TCP header ends, and data begins on a 32-bit boundary.</li>

</ul></li>

</ul>
</div>

</section>
<section>

<div style="font-size: 90%;">
<ul>
<li><b>Flags (9 bits)</b>
<ul>
<li><b>NS–ECN-nonce</b>: Concealment protection.</li>
<li><b>CWR</b>: Congestion Window Reduced; the sender reduced its sending rate.</li>
<li><b>ECE</b>: ECN Echo; the sender received an earlier congestion notification.</li>
<li><b>URG</b>: Urgent; the Urgent Pointer field is valid, but this is rarely used.</li>
<li><b>ACK</b>: Acknowledgment; the Acknowledgment Number field is valid and is always on after a connection is established.</li>
<li><b>PSH</b>: Push; the receiver should pass this data to the application as soon as possible.</li>
<li><b>RST</b>: Reset the connection or connection abort, usually because of an error.</li>
<li><b>SYN</b>: Synchronize sequence numbers to initiate a connection.</li>
<li><b>FIN</b>: The sender of the segment is finished sending data to its peer.</li>

</ul></li>

</ul>
</div>

</section>
<section id="slide-org9f5478f">
<h4 id="org9f5478f">TCP Header in wireshark</h4>
</section>
<section id="slide-org35fd5d7" data-background="./images/tcp-header-wireshark.png" data-background-transition="slide">
<h4 id="org35fd5d7"></h4>

</section>
<section id="slide-orga89fe64">
<h4 id="orga89fe64">TCP State</h4>
</section>
<section id="slide-orgd59bb43" data-background="./images/tcp-state.svg" data-background-size="1000px">
<h4 id="orgd59bb43"></h4>

</section>
<section id="slide-org5e8b564">
<h4 id="org5e8b564">TCP State</h4>
<div style="font-size: 90%;">
<ul>
<li><b>LISTEN</b> (server)
<ul>
<li>Represents waiting for a connection request from any remote TCP and port</li>

</ul></li>

<li><b>SYN-SENT</b> (client)
<ul>
<li>Represents waiting for a matching connection request after sending a connection request</li>

</ul></li>

<li><b>SYN-RECEIVED</b> (server)
<ul>
<li>Represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request</li>

</ul></li>

<li><b>ESTABLISHED</b> (both server and client)
<ul>
<li>Represents an open connection; data received can be delivered to the user—the intermediate state for the data transfer phase of the connection</li>

</ul></li>

<li><b>FIN-WAIT-1</b> (both server and client)
<ul>
<li>Represents waiting for a connection termination request from the remote host</li>

</ul></li>

<li><b>FIN-WAIT-2</b> (both server and client)
<ul>
<li>Represents waiting for a connection termination request from the remote TCP</li>

</ul></li>

</ul>
</div>

</section>
<section>

<div style="font-size: 90%;">
<ul>
<li><b>CLOSE-WAIT</b> (both server and client)
<ul>
<li>Represents waiting for a local user’s connection termination request</li>

</ul></li>

<li><b>CLOSING</b> (both server and client)
<ul>
<li>Represents waiting for a connection termination request acknowledgment from the remote TCP</li>

</ul></li>

<li><b>LAST-ACK</b> (both server and client)
<ul>
<li>Represents waiting for an acknowledgment of the connection termination request previously sent to the remote host</li>

</ul></li>

<li><b>TIME-WAIT</b> (either server or client)
<ul>
<li>Represents waiting for enough time to pass to ensure the remote host received the acknowledgment of its connection termination request</li>

</ul></li>

<li><b>CLOSED</b> (both server and client)
<ul>
<li>Represents no connection state at all</li>

</ul></li>

</ul>
</div>

</section>
<section id="slide-orgab85d9e">
<h3 id="orgab85d9e">TLS Handshake</h3>
<div class="outline-text-3" id="text-orgab85d9e">
</div>
</section>
<section id="slide-orgb713829" data-background="./images/tls-handshake.png" data-background-size="800px">
<h4 id="orgb713829"></h4>

</section>
<section id="slide-orgbb3ab90">
<h4 id="orgbb3ab90">TLS Handshake</h4>
<div style="font-size: 90%;">
<ul>
<li>1. <b>ClientHello</b>: This contains the cipher suites supported by the client and a random number.</li>
<li>2. <b>ServerHello</b>: This message contains the cipher it supports and a random number.</li>
<li>3. <b>ServerCertificate</b>: This contains the server’s certificate and its server public key.</li>
<li>4. <b>ServerHelloDone</b>: This is the end of the ServerHello. If the client receives a request for its certificate, it sends a ClientCertificate message.</li>
<li>5. <b>ClientKeyExchange</b>: Based on the server’s random number, our client generates a random premaster secret, encrypts it with the server’s public key certificate, and sends it to the server.</li>
<li>6. <b>Key Generation</b>: The client and server generate a master secret from the premaster secret and exchange random values.</li>
<li>7. <b>ChangeCipherSpec</b>: Now the client and server swap their ChangeCipherSpec to begin using the new keys for encryption.</li>
<li>8. <b>Finished Client</b>: The client sends the finished message to confirm that the key exchange and authentication were successful.</li>
<li>9. <b>Finished Server</b>: Now, the server sends the finished message to the client to end the handshake.</li>

</ul>
</div>

</section>
<section id="slide-org6a06a8e" data-background="./images/tls-01.png">
<h4 id="org6a06a8e"></h4>

</section>
<section id="slide-orgde59d85" data-background="./images/tls-02.png">
<h4 id="orgde59d85"></h4>

</section>
<section id="slide-org02545f5" data-background="./images/tls-03.png">
<h4 id="org02545f5"></h4>

</section>
<section id="slide-org74db17e" data-background="./images/tls-04.png">
<h4 id="org74db17e"></h4>

</section>
<section id="slide-org4f719df">
<h3 id="org4f719df">VXLAN Header</h3>
<div class="outline-text-3" id="text-org4f719df">
</div>
</section>
<section id="slide-orga202c53" data-background="./images/vxlan-header.png" data-background-size="1000px">
<h4 id="orga202c53"></h4>

</section>
<section id="slide-org394b4b8">
<h4 id="org394b4b8">VXLAN Header in wireshark</h4>
</section>
<section id="slide-org502e57b" data-background="./images/vxlan-header-wireshark.png" data-background-transition="slide">
<h4 id="org502e57b"></h4>


</section>
</section>
<section>
<section id="slide-orgd5edf54">
<h2 id="orgd5edf54">Linux Networking</h2>
<ul>
<li>Linux network devices</li>
<li>Netfilter</li>
<li>Ipvs</li>
<li>eBPF</li>

</ul>

</section>
<section id="slide-org99bfc63">
<h3 id="org99bfc63">Linux network devices</h3>
<div class="outline-text-3" id="text-org99bfc63">
</div>
</section>
<section id="slide-org4d011e7">
<h4 id="org4d011e7">bridge and veth</h4>
<div style="font-size: 90%;">
<ul>
<li><b>Bridge</b>
<ul>
<li>the bridge functions like a network switch between network interfaces on a host, seamlessly connecting them.</li>

</ul></li>

</ul>

<div class="org-src-container">

<pre><code class="bash" data-line-numbers># Add a new bridge interface named br0.
ip link add br0 type bridge
# Attach eth0 to our bridge.
ip link set eth0 master br0
# Attach veth to our bridge.
ip link set veth master br0
</code></pre>
</div>

<ul>
<li><b>Veth</b>
<ul>
<li>The veth device is a local Ethernet tunnel. Veth devices are created in pairs. Packets transmitted on one device in the pair are immediately received on the other device. When either device is down, the link state of the pair is down. Adding a bridge to Linux can be done with using the <code>brctl</code> commands or <code>ip</code>.</li>

</ul></li>

</ul>

<div class="org-src-container">

<pre><code class="bash" data-line-numbers>ip netns add net1
ip netns add net2
ip link add veth1 netns net1 type veth peer name veth2 netns net2
</code></pre>
</div>
</div>
</section>
<section id="slide-orga19e0bd" data-background="./images/linux-bridge-interface.png" data-background-size="500px">
<h4 id="orga19e0bd"></h4>

</section>
<section id="slide-org89e8314">
<h4 id="org89e8314">tun and tap</h4>
<div style="font-size: 90%;">
<ul>
<li><b>TUN</b>
<ul>
<li>tunnel devices operate at <b>layer 3</b>, meaning the data (packets) you will receive from the file descriptor will be IP based. Data written back to the device must also be in the form of an IP packet.</li>

</ul></li>
<li><b>TAP</b>
<ul>
<li>network tap operates much like TUN however instead of only being able to write and receive layer 3 packets to/from the file descriptor it can use <b>raw ethernet</b> packets. You will typically see TAP devices used by KVM/Qemu virtualization, where a TAP device is assigned to a virtual guest interface during creation.</li>

</ul></li>

</ul>
</div>

</section>
<section id="slide-org911899c" data-background="./images/linux-network-device.png" data-background-size="1200px">
<h4 id="org911899c"></h4>

</section>
<section id="slide-org8d18a34">
<h3 id="org8d18a34">Netfilter</h3>
<div style="font-size: 90%;">
<ul>
<li>The <b>netfilter project</b> is a community-driven collaborative FOSS project that provides packet filtering software for the Linux 2.4.x and later kernel series. The netfilter project is commonly associated with iptables and its successor nftables.</li>
<li>The <b>netfilter</b> project enables packet filtering, network address [and port] translation (NA[P]T), packet logging, userspace packet queueing and other packet mangling.</li>
<li>The <b>netfilter hooks</b> are a framework inside the Linux kernel that allows kernel modules to register callback functions at different locations of the Linux network stack. The registered callback function is then called back for every packet that traverses the respective hook within the Linux network stack.</li>
<li><b>iptables</b> is a generic firewalling software that allows you to define rulesets. Each rule within an IP table consists of a number of classifiers (iptables matches) and one connected action (iptables target).</li>

</ul>
</div>

</section>
<section>

<div style="font-size: 90%; text-align: left;">
<ul>
<li><b>nftables</b> is the successor of iptables, it allows for much more flexible, scalable and performance packet classification. This is where all the fancy new features are developed.</li>

</ul>

<p>
reference:
</p>
<ul>
<li><a href="https://www.teldat.com/blog/nftables-and-netfilter-hooks-via-linux-kernel/">https://www.teldat.com/blog/nftables-and-netfilter-hooks-via-linux-kernel/</a></li>
<li><a href="https://www.netfilter.org/">https://www.netfilter.org/</a></li>
<li><a href="https://www.fatalerrors.org/a/0tx80Dw.html">https://www.fatalerrors.org/a/0tx80Dw.html</a></li>

</ul>
</div>

</section>
<section id="slide-orgd7af8c3" data-background="./images/netfilter-framework.jpeg" data-background-size="1000px">
<h4 id="orgd7af8c3"></h4>

</section>
<section id="slide-org2d702e3" data-background="./images/packet-flow-in-netfilter.svg" data-background-size="1400px">
<h4 id="org2d702e3"></h4>

</section>
<section id="slide-orga60314b">
<h4 id="orga60314b">Netfilter hooks</h4>
<div style="font-size: 70%;">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Netfilter hook</th>
<th scope="col" class="org-left">Iptables chain name</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>NF_IP_PRE_ROUTING</code></td>
<td class="org-left">PREROUTING</td>
<td class="org-left">Triggers when a packet arrives from an external system.</td>
</tr>

<tr>
<td class="org-left"><code>NF_IP_LOCAL_IN</code></td>
<td class="org-left">INPUT</td>
<td class="org-left">Triggers when a packet’s destination IP address matches this machine.</td>
</tr>

<tr>
<td class="org-left"><code>NF_IP_FORWARD</code></td>
<td class="org-left">NAT</td>
<td class="org-left">Triggers for packets where neither source nor destination matches the machine’s IP addresses.</td>
</tr>

<tr>
<td class="org-left"><code>NF_IP_LOCAL_OUT</code></td>
<td class="org-left">OUTPUT</td>
<td class="org-left">Triggers when a packet, originating from the machine, is leaving the machine.</td>
</tr>

<tr>
<td class="org-left"><code>NF_IP_POST_ROUTING</code></td>
<td class="org-left">POSTROUTING</td>
<td class="org-left">Triggers when any packet (regardless of origin) is leaving the machine.</td>
</tr>
</tbody>
</table>
</div>

</section>
<section id="slide-org09b92ec" data-background="./images/iptables-table-chain.png" data-background-size="1000px">
<h4 id="org09b92ec"></h4>

</section>
<section id="slide-orgf507266">
<h4 id="orgf507266">data structure</h4>
<div style="font-size: 90%; text-align: left;">
<p>
The structure corresponds to the tables in iptables. At present, the kernel registers tables of filter, mangle, nat and raw. 
</p>

<div class="org-src-container">

<pre><code class="c" data-line-numbers="1,15-16">struct xt_table
{
  //All the tables are registered in the xt linked list of the network namespace;
  struct list_head list;

  //Name of table, such as "filter", "nat","mangle"
  const char name[XT_TABLE_MAXNAMELEN];

  //It is used by bit to indicate which HOOK point rules and 5 hooks are saved in the table
  unsigned int valid_hooks;

  //This lock protects the contents of the private pointer in the table
  rwlock_t lock;

  //It actually points to struct xt_table_info object, as defined below
  void *private;

  /* Set this to THIS_MODULE if you are a module, otherwise NULL */
  struct module *me;

  //Which protocol family does the table belong to
  int af;		/* address/protocol family */
};

struct net {
  ...
#ifdef CONFIG_NETFILTER
  struct netns_xt		xt;
#endif
};
struct netns_xt {
  struct list_head tables[NPROTO];
};
</code></pre>
</div>

<p>
source code: <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/netfilter/x_tables.h#L223">https://elixir.bootlin.com/linux/latest/source/include/linux/netfilter/x_tables.h#L223</a>
</p>
</div>

</section>
<section>

<div style="font-size: 90%; text-align: left;">
<p>
Structure <code>xt_table</code> is only a basic description of table and does not save the rules in table. More table contents are in its private member, and the structure pointed to by this member is struct <code>xt_talble_info</code> object, which is defined as follows.
</p>

<div class="org-src-container">

<pre><code class="c" data-line-numbers="1,17-20">struct xt_table_info
{
  //Memory size of all rules in table
  unsigned int size;
  //Number of rules currently saved in table
  unsigned int number;
  //The number of rules in the table at initial registration
  /* Initial number of entries. Needed for module usage count */
  unsigned int initial_entries;
  //Each table can save rules of multiple HOOK points (by the table's valid_hook),
  //After entering from a HOOK point, only the rules on the HOOK point should be checked when checking rules
  //In order to delimit the rules in the table according to the HOOK point, there are two members as follows:
  //hook_entry [] records the offset of the first rule of each HOOK point from entries;
  //Under flow [] records the offset of the last rule of each HOOK point from the entries
  unsigned int hook_entry[NF_INET_NUMHOOKS];
  unsigned int underflow[NF_INET_NUMHOOKS];
  //The rule in table is that each CPU has a copy. This is to avoid mutual exclusion between multiple CPUs,
  //Therefore, the entries are allocated according to the number of CPUs. For example, if there are two CPUs, two char pointers will be allocated
  //The CPU ID is used to index
  char *entries[1];
};
//The following auxiliary macro is used to calculate struct XT_ table_ The memory size of the info object,
//Note that the entries have been sized according to the number of CPU s
#define XT_TABLE_INFO_SZ (offsetof(struct xt_table_info, entries) \
                          + nr_cpu_ids * sizeof(char *))
</code></pre>
</div>
</div>

</section>
<section id="slide-org1e67ea3">
<h4 id="org1e67ea3">netfilter table chain</h4>
</section>
<section id="slide-org6d85368" data-background="./images/netfilter-table-chain.jpeg" data-background-size="1200px">
<h4 id="org6d85368"></h4>

</section>
<section id="slide-orgcec51dd">
<h3 id="orgcec51dd">Ipvs</h3>
<ul>
<li><b>DR</b> directly routes packets to the backend server by rewriting the MAC address of the data frame with the MAC address of the selected backend server.</li>
<li><b>IP tunneling</b> encapsulates IP datagrams within IP datagrams.</li>
<li><b>NAT</b> rewrites source and destination addresses.</li>

<li>reference:
<ul>
<li><a href="http://www.linuxvirtualserver.org/Documents.html">http://www.linuxvirtualserver.org/Documents.html</a></li>
<li><a href="https://debugged.it/blog/ipvs-the-linux-load-balancer/">https://debugged.it/blog/ipvs-the-linux-load-balancer/</a></li>

</ul></li>

</ul>

</section>
<section id="slide-org327a7ab" data-background="./images/ipvs-dr-mode.svg" data-background-size="1000px">
<h4 id="org327a7ab"></h4>

</section>
<section id="slide-orgebbc3de" data-background="./images/ipvs-nat-mode.svg" data-background-size="600px">
<h4 id="orgebbc3de"></h4>

</section>
<section id="slide-org7735851" data-background="./images/ipvs-tun-mode.svg" data-background-size="1200px">
<h4 id="org7735851"></h4>

</section>
<section id="slide-orgb26450a">
<h4 id="orgb26450a">iptables issues</h4>
<div style="font-size: 90%; text-align: left;">
<p>
There are three aspects to look at when it comes to issues with iptables as a load balancer:
</p>

<ul>
<li>Number of nodes in the cluster
<ul>
<li>Even though Kubernetes already supports 5,000 nodes in release v1.6, kube-proxy with iptables is a bottleneck to scale the cluster to 5,000 nodes. One example is that with a NodePort service in a 5,000-node cluster, if we have 2,000 services and each service has 10 pods, this will cause at least 20,000 iptables records on each worker node, which can make the kernel pretty busy.</li>

</ul></li>

<li>Time
<ul>
<li>The time spent to add one rule when there are 5,000 services (40,000 rules) is 11 minutes. For 20,000 services (160,000 rules), it’s 5 hours.</li>

</ul></li>

<li>Latency
<ul>
<li>There is latency to access a service (routing latency); each packet must traverse the iptables list until a match is made. There is latency to add/remove rules, inserting and removing from an extensive list is an intensive operation at scale.</li>

</ul></li>

</ul>

</div>
</section>
<section id="slide-org3a6a493" data-background="./images/kubernetes-ipvs.png" data-background-size="800px">
<h4 id="org3a6a493"></h4>

</section>
<section id="slide-orga452c54">
<h3 id="orga452c54">eBPF</h3>
<div style="font-size: 90%; text-align: left;">
<p>
<b>eBPF</b> is a programming system that allows special sandboxed programs to run in the kernel without passing back and forth between kernel and user space, like we saw with Netfilter and iptables.
</p>

<p>
In addition to socket filtering, other supported attach points in the kernel are as follows:
</p>

<ul>
<li><b>Kprobes</b>
<ul>
<li>Dynamic kernel tracing of internal kernel components.</li>

</ul></li>

<li><b>Uprobes</b>
<ul>
<li>User-space tracing.</li>

</ul></li>

<li><b>Tracepoints</b>
<ul>
<li>Kernel static tracing. These are programed into the kernel by developers and are more stable as compared to kprobes, which may change between kernel versions.</li>

</ul></li>

<li><b>perf<sub>events</sub></b>
<ul>
<li>Timed sampling of data and events.</li>

</ul></li>

<li><b>XDP</b>
<ul>
<li>Specialized eBPF programs that can go lower than kernel space to access driver space to act directly on packets.</li>

</ul></li>

</ul>

</div>

</section>
<section id="slide-org033c426" data-background="./images/ebpf-example.png" data-background-size="600px">
<h4 id="org033c426"></h4>

</section>
<section id="slide-org7c48fc4" data-background="./images/cilium-interacts-with-ebpf.png" data-background-size="1000px">
<h4 id="org7c48fc4"></h4>


</section>
</section>
<section>
<section id="slide-orgd6f1e48">
<h2 id="orgd6f1e48">Kubernetes networking model</h2>
<ul>
<li>Pod Networking</li>
<li>Service Routing</li>

</ul>

</section>
<section id="slide-orgd95c9d7">
<h3 id="orgd95c9d7">Pod Networking</h3>
<ul>
<li>CNI(Container Networking Interface)</li>
<li>Overlay Networking</li>
<li>Routing</li>

</ul>

</section>
<section id="slide-orgdedd21d">
<h4 id="orgdedd21d">Concepts</h4>
<div style="font-size: 90%; text-align: left;">
<ul>
<li><b>VTEP</b> 
<ul>
<li>VXLAN Tunnel Endpoints, performs data frame encapsulation and decapsulation. The VTEP peer interaction ensures that the data gets forwarded to the relevant destination container addresses. The data leaving the containers is encapsulated with VXLAN information and transferred over the VXLAN tunnels to be de-encapsulated by the peer VTEP.</li>

</ul></li>

</ul>
</div>

</section>
<section id="slide-orgd706eb4">
<h4 id="orgd706eb4">CNI</h4>
<div style="font-size: 90%; text-align: left;">
<p>
Kubernetes relies on the CNI project to comply with the following requirements:
</p>

<ul>
<li>All containers must communicate with each other without NAT.</li>
<li>Nodes can communicate with containers without NAT.</li>
<li>A container’s IP address is the same as those outside the container that it sees itself as.</li>

</ul>
</div>

</section>
<section>

<div style="font-size: 90%; text-align: left;">
<ul>
<li><b>CNI</b>
<ul>
<li>The CNI specification defines a few key operations:</li>

<li>ADD
<ul>
<li>Adds a container to the network and responds with the associated interface(s), IP(s), and more.</li>

</ul></li>

<li>DELETE
<ul>
<li>Removes a container from the network and releases all associated resources.</li>

</ul></li>

<li>CHECK
<ul>
<li>Verifies a container’s network is set up properly and responds with an error if there are issues.</li>

</ul></li>

<li>VERSION
<ul>
<li>Returns the CNI version(s) supported by the plug-in.</li>

</ul></li>

</ul></li>

</ul>
</div>

</section>
<section id="slide-org8898bba">
<h4 id="org8898bba">Overlay Networking</h4>
</section>
<section id="slide-org53502ef" data-background="./images/vxlan-tunnel-detailed.png" data-background-size="800px">
<h4 id="org53502ef"></h4>
</section>
<section id="slide-org2776f3f" data-background="./images/vxlan-encapsulation.png" data-background-size="800px">
<h4 id="org2776f3f"></h4>

</section>
<section id="slide-orgbf541a9">
<h4 id="orgbf541a9">Routing</h4>
<div style="font-size: 90%; text-align: left;">
<p>
<b>Border Gateway Protocol (BGP)</b> is one of the most commonly used protocols to distribute workload routes. It is used in projects such as Calico and Kube-Router. Not only does BGP enable communication of workload routes in the cluster but its internal routers can also be peered with external routers. Doing so can make external network fabrics aware of how to route to Pod IPs.
</p>

</div>
</section>
<section id="slide-org40d1466" data-background="./images/calico-routing.png" data-background-size="800px">
<h4 id="org40d1466"></h4>

</section>
<section id="slide-org656edae">
<h4 id="org656edae">Calico</h4>
<div style="font-size: 90%; text-align: left;">
<p>
Calico offers a variety of ways to route packets inside of the cluster. This includes:
</p>

<ul>
<li>Native
<ul>
<li>No encapsulation of packets.</li>

</ul></li>

<li>IP-in-IP
<ul>
<li>Simple encapsulation. IP packet is placed in the payload of another.</li>

</ul></li>

<li>VXLAN
<ul>
<li>Advanced encapsulation. An entire L2 frame is encapsulated within a UDP packet. Establishes a virtual L2 overlay.the VXLAN mode does not require usage of BGP, which can be a solution to environments where BGP peering is blocked.</li>

</ul></li>

</ul>

</div>
</section>
<section id="slide-org5b4d820" data-background="./images/calico-component-relationship.png" data-background-size="800px">
<h4 id="org5b4d820"></h4>

</section>
<section id="slide-org03fb045" data-background="./images/calico-crosssubnet-mode.png" data-background-size="800px">
<h4 id="org03fb045"></h4>

</section>
<section id="slide-orgba5e6ab">
<h3 id="orgba5e6ab">Service Routing</h3>
<ul>
<li>ClusterIP</li>
<li>NodePort</li>
<li>LoadBalancer</li>
<li>Ingress</li>

</ul>

</section>
<section id="slide-org9d1f9a1">
<h4 id="org9d1f9a1">Service Implementation</h4>
<ul>
<li>Kube-proxy
<ul>
<li>Kube-proxy is an agent that runs on every cluster node. It is primarily responsible for making Services available to the Pods running on the local node. It achieves this by watching the API server for Services and Endpoints and programming the Linux networking stack (using iptables, for example) to handle packets accordingly.</li>
<li>Historically, kube-proxy acted as a network proxy between Pods running on the node and Services. This is where the kube-proxy name came from. As the Kubernetes project evolved, however, kube-proxy stopped being a proxy and became more of a node agent or localized control plane.</li>

</ul></li>

</ul>

</section>
<section id="slide-org811b350">
<h4 id="org811b350">ClusterIP</h4>
<ul>
<li>ClusterIP Service creates a virtual IP address (VIP) that is backed by one or more Pods. Usually, the VIP is available only to workloads running inside the cluster.</li>

</ul>

</section>
<section id="slide-org759c75e" data-background="./images/clusterip-service.png" data-background-size="800px">
<h4 id="org759c75e"></h4>

</section>
<section id="slide-org742cf37">
<h4 id="org742cf37">NodePort</h4>
<div style="font-size: 90%; text-align: left;">
<p>
The <b>NodePort</b> Service is useful when you need to expose a Service to network clients outside of the cluster, such as existing applications running in VMs or users of a web application.
</p>

<p>
As the name suggests, the NodePort Service exposes the Service on a port across all cluster nodes. The port is assigned randomly from a configurable port range. Once assigned, all nodes in the cluster listen for connections on the given port.
</p>
</div>
</section>
<section id="slide-orga762d22" data-background="./images/nodeport-service.png" data-background-size="800px">
<h4 id="orga762d22"></h4>

</section>
<section id="slide-orge1bdd32">
<h4 id="orge1bdd32">LoadBalancer</h4>
<div style="font-size: 90%; text-align: left;">
<p>
The <b>LoadBalancer</b> Service builds upon the NodePort Service to address some of its downsides. At its core, the LoadBalancer Service is a NodePort Service under the hood. However, the LoadBalancer Service has additional functionality that is satisfied by a controller.
</p>

<p>
The controller, also known as a cloud provider integration, is responsible for automatically gluing the NodePort Service with an external load balancer. In other words, the controller takes care of creating, managing, and configuring external load balancers in response to the configuration of LoadBalancer Services in the cluster. The controller does this by interacting with APIs that provision or configure load balancers.
</p>
</div>

</section>
<section id="slide-orgbca0160" data-background="./images/loadbalancer-service.png" data-background-size="800px">
<h4 id="orgbca0160"></h4>

</section>
<section id="slide-org06c4c7d">
<h4 id="org06c4c7d">Ingress</h4>
<div style="font-size: 90%; text-align: left;">
<p>
<b>Ingress</b> is a Kubernetes-specific L7 (HTTP) load balancer, which is accessible externally, contrasting with L4 ClusterIP service, which is internal to the cluster. This is the typical choice for exposing an HTTP(S) workload to external users. An ingress can be a single entry point into an API or a microservice-based architecture. Traffic can be routed to services based on HTTP information in the request. Ingress is a configuration spec (with multiple implementations) for routing HTTP traffic to Kubernetes services.
</p>
</div>

</section>
<section id="slide-org14157bf" data-background="./images/ingress-architecture.png" data-background-size="800px">
<h4 id="org14157bf"></h4>

</section>
<section id="slide-org8f78ef3" data-background="./images/ingress-traffic.png" data-background-size="800px">
<h4 id="org8f78ef3"></h4>


</section>
</section>
<section>
<section id="slide-orgd123589">
<h2 id="orgd123589">Q&amp;A</h2>
</section>
</section>
</div>
</div>
<script src="/Users/kangxiaoning/workspace/reveal.js/dist/reveal.js"></script>
<script src="/Users/kangxiaoning/workspace/reveal.js/plugin/highlight/highlight.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,
width: 1400,
height: 1000,

transition: 'convex',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealHighlight ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
